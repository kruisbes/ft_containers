#include "pair.hpp"
#include "rbtree.hpp"
#include "get_first.hpp"
#include "map.hpp"


//template <typename T>
//class BinTree {
//	struct Node {
//		T value;
//		Node *left,*right;
//		Node() : left(nullptr),right(nullptr) {}
//		Node(const T& value) :value(value),left(nullptr),right(nullptr) {}
//		// stack-abusing recursion everywhere, for small code
//		~Node() { delete left; delete right; }
//		int max_depth() const {
//			const int left_depth = left ? left->max_depth() : 0;
//			const int right_depth = right ? right->max_depth() : 0;
//			return (left_depth > right_depth ? left_depth : right_depth) + 1;
//		}
//	};
//
//	Node *root;
//
//public:
//	BinTree() : root(nullptr) {}
//	~BinTree() { delete root; }
//
//	int get_max_depth() const { return root ? root->max_depth() : 0; }
//	void clear() { delete root; root = nullptr; }
//	void insert() {}
//	template <typename ...Args>
//	void insert(const T& value, Args...more) {
//		if(!root) {
//			root = new Node(value);
//		} else {
//			Node* p = root;
//			for(;;) {
//				if(value == p->value) return;
//				Node* &pchild = value < p->value ? p->left : p->right;
//				if(!pchild) {
//					pchild = new Node(value);
//					break;
//				}
//				p = pchild;
//			}
//		}
//		insert(more...);
//	}
//
//	struct cell_display {
//		string   valstr;
//		bool     present;
//		cell_display() : present(false) {}
//		cell_display(std::string valstr) : valstr(valstr), present(true) {}
//	};
//
//	using display_rows = vector< vector< cell_display > >;
//
//	// The text tree generation code below is all iterative, to avoid stack faults.
//
//	// get_row_display builds a vector of vectors of cell_display structs
//	// each vector of cell_display structs represents one row, starting at the root
//	display_rows get_row_display() const {
//		// start off by traversing the tree to
//		// build a vector of vectors of Node pointers
//		vector<Node*> traversal_stack;
//		vector< std::vector<Node*> > rows;
//		if(!root) return display_rows();
//
//		Node *p = root;
//		const int max_depth = root->max_depth();
//		rows.resize(max_depth);
//		int depth = 0;
//		for(;;) {
//			// Max-depth Nodes are always a leaf or null
//			// This special case blocks deeper traversal
//			if(depth == max_depth-1) {
//				rows[depth].push_back(p);
//				if(depth == 0) break;
//				--depth;
//				continue;
//			}
//
//			// First visit to node?  Go to left child.
//			if(traversal_stack.size() == depth) {
//				rows[depth].push_back(p);
//				traversal_stack.push_back(p);
//				if(p) p = p->left;
//				++depth;
//				continue;
//			}
//
//			// Odd child count? Go to right child.
//			if(rows[depth+1].size() % 2) {
//				p = traversal_stack.back();
//				if(p) p = p->right;
//				++depth;
//				continue;
//			}
//
//			// Time to leave if we get here
//
//			// Exit loop if this is the root
//			if(depth == 0) break;
//
//			traversal_stack.pop_back();
//			p = traversal_stack.back();
//			--depth;
//		}
//
//		// Use rows of Node pointers to populate rows of cell_display structs.
//		// All possible slots in the tree get a cell_display struct,
//		// so if there is no actual Node at a struct's location,
//		// its boolean "present" field is set to false.
//		// The struct also contains a string representation of
//		// its Node's value, created using a std::stringstream object.
//		display_rows rows_disp;
//		std::stringstream ss;
//		for(const auto& row : rows) {
//			rows_disp.emplace_back();
//			for(Node* pn : row) {
//				if(pn) {
//					ss << pn->value;
//					rows_disp.back().push_back(cell_display(ss.str()));
//					ss = std::stringstream();
//				} else {
//					rows_disp.back().push_back(cell_display());
//				}   }   }
//		return rows_disp;
//	}
//
//	// row_formatter takes the vector of rows of cell_display structs
//	// generated by get_row_display and formats it into a test representation
//	// as a vector of strings
//	vector<string> row_formatter(const display_rows& rows_disp) const {
//		using s_t = string::size_type;
//
//		// First find the maximum value string length and put it in cell_width
//		s_t cell_width = 0;
//		for(const auto& row_disp : rows_disp) {
//			for(const auto& cd : row_disp) {
//				if(cd.present && cd.valstr.length() > cell_width) {
//					cell_width = cd.valstr.length();
//				}   }   }
//
//		// make sure the cell_width is an odd number
//		if(cell_width % 2 == 0) ++cell_width;
//
//		// allows leaf nodes to be connected when they are
//		// all with size of a single character
//		if(cell_width < 3) cell_width = 3;
//
//
//		// formatted_rows will hold the results
//		vector<string> formatted_rows;
//
//		// some of these counting variables are related,
//		// so its should be possible to eliminate some of them.
//		s_t row_count = rows_disp.size();
//
//		// this row's element count, a power of two
//		s_t row_elem_count = 1 << (row_count-1);
//
//		// left_pad holds the number of space charactes at the beginning of the bottom row
//		s_t left_pad = 0;
//
//		// Work from the level of maximum depth, up to the root
//		// ("formatted_rows" will need to be reversed when done)
//		for(s_t r=0; r<row_count; ++r) {
//			const auto& cd_row = rows_disp[row_count-r-1]; // r reverse-indexes the row
//			// "space" will be the number of rows of slashes needed to get
//			// from this row to the next.  It is also used to determine other
//			// text offsets.
//			s_t space = (s_t(1) << r) * (cell_width + 1) / 2 - 1;
//			// "row" holds the line of text currently being assembled
//			string row;
//			// iterate over each element in this row
//			for(s_t c=0; c<row_elem_count; ++c) {
//				// add padding, more when this is not the leftmost element
//				row += string(c ? left_pad*2+1 : left_pad, ' ');
//				if(cd_row[c].present) {
//					// This position corresponds to an existing Node
//					const string& valstr = cd_row[c].valstr;
//					// Try to pad the left and right sides of the value string
//					// with the same number of spaces.  If padding requires an
//					// odd number of spaces, right-sided children get the longer
//					// padding on the right side, while left-sided children
//					// get it on the left side.
//					s_t long_padding = cell_width - valstr.length();
//					s_t short_padding = long_padding / 2;
//					long_padding -= short_padding;
//					row += string(c%2 ? short_padding : long_padding, ' ');
//					row += valstr;
//					row += string(c%2 ? long_padding : short_padding, ' ');
//				} else {
//					// This position is empty, Nodeless...
//					row += string(cell_width, ' ');
//				}
//			}
//			// A row of spaced-apart value strings is ready, add it to the result vector
//			formatted_rows.push_back(row);
//
//			// The root has been added, so this loop is finsished
//			if(row_elem_count == 1) break;
//
//			// Add rows of forward- and back- slash characters, spaced apart
//			// to "connect" two rows' Node value strings.
//			// The "space" variable counts the number of rows needed here.
//			s_t left_space  = space + 1;
//			s_t right_space = space - 1;
//			for(s_t sr=0; sr<space; ++sr) {
//				string row;
//				for(s_t c=0; c<row_elem_count; ++c) {
//					if(c % 2 == 0) {
//						row += string(c ? left_space*2 + 1 : left_space, ' ');
//						row += cd_row[c].present ? '/' : ' ';
//						row += string(right_space + 1, ' ');
//					} else {
//						row += string(right_space, ' ');
//						row += cd_row[c].present ? '\\' : ' ';
//					}
//				}
//				formatted_rows.push_back(row);
//				++left_space;
//				--right_space;
//			}
//			left_pad += space + 1;
//			row_elem_count /= 2;
//		}
//
//		// Reverse the result, placing the root node at the beginning (top)
//		std::reverse(formatted_rows.begin(), formatted_rows.end());
//
//		return formatted_rows;
//	}
//
//	// Trims an equal number of space characters from
//	// the beginning of each string in the vector.
//	// At least one string in the vector will end up beginning
//	// with no space characters.
//	static void trim_rows_left(vector<string>& rows) {
//		if(!rows.size()) return;
//		auto min_space = rows.front().length();
//		for(const auto& row : rows) {
//			auto i = row.find_first_not_of(' ');
//			if(i==string::npos) i = row.length();
//			if(i == 0) return;
//			if(i < min_space) min_space = i;
//		}
//		for(auto& row : rows) {
//			row.erase(0, min_space);
//		}   }
//
//	// Dumps a representation of the tree to cout
//	void Dump() const {
//		const int d = get_max_depth();
//
//		// If this tree is empty, tell someone
//		if(d == 0) {
//			cout << " <empty tree>\n";
//			return;
//		}
//
//		// This tree is not empty, so get a list of node values...
//		const auto rows_disp = get_row_display();
//		// then format these into a text representation...
//		auto formatted_rows = row_formatter(rows_disp);
//		// then trim excess space characters from the left sides of the text...
//		trim_rows_left(formatted_rows);
//		// then dump the text to cout.
//		for(const auto& row : formatted_rows) {
//			std::cout << ' ' << row << '\n';
//		}
//	}
//};


int main() {
	ft::rbTree<int, ft::pair<char, int>, ft::get_first<ft::pair<char, int> > > tree;
	tree.insert(ft::pair<char, int>('a', 100));
	tree.insert(ft::pair<char, int>('z', 200));
	ft::rbTree<int, ft::pair<char, int>, ft::get_first<ft::pair<int, int> > >::iterator it = tree.begin();
	tree.insert(it, ft::pair<char, int>('b', 300));
	tree.insert(it, ft::pair<char, int>('c', 400));

	tree.balance();
	tree.printRBT();
	std::cout << "tree contains: " << std::endl;
	for (it=tree.begin(); it!=tree.end(); ++it)
		std::cout << it->first << " => " << it->second << std::endl;
	std::cout << tree.find('a')->second << std::endl;
//	ft::map<char, int> my;
//	my.insert(ft::pair<char, int>('a', 100));
//	my.insert(ft::pair<char, int>('z', 200));
//	ft::pair<ft::map<char, int>::iterator, bool> ret;
//	ret = my.insert(ft::pair<char, int>('z', 500));
//	// second insert function version (with hint position):
//	ft::map<char,int>::iterator it = my.begin();
//	my.insert (it, ft::pair<char,int>('b',300));  // max efficiency inserting
//	my.insert (it, ft::pair<char,int>('c',400));  // no max efficiency inserting
//
//	// third insert function version (range insertion):
//	ft::map<char,int> anothermap;
////	anothermap._insert(my.begin(),my.find('c'));
//
//
//	// showing contents:
//	std::cout << "mymap contains:\n";
//	for (it=my.begin(); it!=my.end(); ++it)
//		std::cout << it->first << " => " << it->second << '\n';
//
//	std::cout << "anothermap contains:\n";
//	for (it=anothermap.begin(); it!=anothermap.end(); ++it)
//		std::cout << it->first << " => " << it->second << '\n';
//
//	return 0;
//	ft::pair<int, int> b(10, 15);
//	ft::rbTree<int, ft::pair<int, int>, ft::get_first<ft::pair<int, int> > > a;
//	a.insert_unique(b);
//	std::cout << a.begin().node->val.second << std::endl;
//	ft::rbTree<int, ft::pair<int, int>, ft::get_first<ft::pair<int, int> > >::iterator aa = a.begin();
//	std::cout << aa->first << std::endl;
//	ft::rbTree<int, ft::pair<int, int>, ft::get_first<ft::pair<int, int> > >::const_iterator aaaa = a.begin();
//	std::cout << aaaa->first << std::endl;
//	ft::pair<int, int> c(11, 16);
//	a.insert_unique(a.begin(), c);
//	std::cout << a.begin().node->val.second << std::endl;
//	ft::rbTree<int, ft::pair<int, int>, ft::get_first<ft::pair<int, int> > >::iterator p = a.begin();
//	++p++;
//	ft::rbTree<int, ft::pair<int, int>, ft::get_first<ft::pair<int, int> > > test;
//	test.insert_unique(a.begin(), a.end());
//	ft::map<int, int> mapp;
//	mapp.insert(b);
//	std::cout << ((a.begin())+2).node->val.second << std::endl;
//	ft::pair<int, int> pair(13,15);
//	ft::pair<int, int> pair2(11,15);
//	ft::rbNode<ft::pair<int, int> >* a = new (ft::rbNode<ft::pair<int, int> >);
//	a->val = pair;
//	ft::rbNode<ft::pair<int, int> >* b = new (ft::rbNode<ft::pair<int, int> >);
//	b->val = pair2;
//	b->right = 0;
//	a->right = b;
//	ft::rbNode<ft::pair<int, int> > f;
////	ft::rb_iterator<ft::pair<int, int> > b;
//	ft::rb_const_iterator<ft::pair<int, int> > c;
//
//	ft::rbTree<char, ft::pair<int, char>, int> dnk;
//	dnk.begin();
//	dnk.end();
//	std::cout << dnk.max_size() << std::endl;
//	std::cout << dnk.size() << std::endl;
//	ft::rbTree<char, ft::pair<int, char>, int > one(dnk);
//	ft::rbTree<char, ft::pair<int, char>, int > lol;
//	lol.equal_range('l');


//	ft::rbTree<char, ft::pair<int, int>, int> A;
//	ft::rbTree<char, ft::pair<int, int>, int> B(A);
//
//	std::cout << A.size() << " " << B.size() << std::endl;
 //	std::cout << ft::rbNode<ft::pair<int, int> >::maximum(a)->val.first << std::endl;
//	std::allocator<int> alloc;
//	std::map<int,int> first;
//
//	first['a']=10;
//	first['b']=30;
//	first['c']=50;
//	first['d']=70;
//
//	std::cout << first[97] << std::endl;
//	std::cout << first[98] << std::endl;
//	std::map<int, std::map<int, int> > second;
//	second[0] = first;
//	std::cout << second[0][100] << std::endl;
//
//	std::map<int, int>::iterator it = first.begin();
//	return 0;
//	ft::pair <std::string,double> product1;                     // default constructor
//	ft::pair <std::string,double> product2 ("tomatoes",2.30);   // value init
//	ft::pair <std::string,double> product3 (product2);          // copy constructor
//
//	product1 = ft::make_pair(std::string("lightbulbs"),0.99);   // using make_pair (move)
//
//	product2.first = "shoes";                  // the type of first is string
//	product2.second = 39.90;                   // the type of second is double
//
//	std::cout << "The price of " << product1.first << " is $" << product1.second << std::endl;
//	std::cout << "The price of " << product2.first << " is $" << product2.second << std::endl;
//	std::cout << "The price of " << product3.first << " is $" << product3.second << std::endl;
//
//	std::cout << std::endl;
//
//	ft::pair<int,char> foo (10,'z');
//	ft::pair<int,char> bar (90,'a');
//
//	if (foo==bar) std::cout << "foo and bar are equal\n";
//	if (foo!=bar) std::cout << "foo and bar are not equal\n";
//	if (foo< bar) std::cout << "foo is less than bar\n";
//	if (foo> bar) std::cout << "foo is greater than bar\n";
//	if (foo<=bar) std::cout << "foo is less than or equal to bar\n";
//	if (foo>=bar) std::cout << "foo is greater than or equal to bar\n";
//
//	std::cout << std::endl;
//
//	ft::pair <std::string,int> planet, homeplanet;
//
//	planet = ft::make_pair("Earth",6371);
//
//	homeplanet = planet;
//
//	std::cout << "Home planet: " << homeplanet.first << '\n';
//	std::cout << "Planet size: " << homeplanet.second << '\n';
//	return 0;
}
